<!--
const Input = await use("@/components/form/input.x.html");
20250618
v.1.1
-->

<script setup type="module">
  const { Ref, State } = await use("@/rollostate/");
  const { is_number } = await use("@/rollotools/is/is_number.js");
  const { is_numeric } = await use("@/rollotools/is/is_numeric.js");
  const { base, component } = await use("@/rollocomponent/");
  const { create_id } = await use("@/components/form/tools/id.js");
  const { get_message } = await use("@/components/form/tools/message.js");

  export default async (assets) => {
    return class extends base("input") {
      static __key__ = "rollo-input";

      #_ = {
        numchars: ["", "-", ".", ","],
        states: {},
        types: ["email", "numeric", "password", "search", "tel", "text", "url"],
      };

      constructor() {
        super();

        /* Init message state */
        this.#_.states.message = new Ref({
          name: "message",
          owner: this,
        }).effects.add(
          /* Set message attribute */
          (current) => {
            this.attribute.message = current;
          }
        ).effects.add((current) => {
            this.classes.if(
              this.attribute.visited && current,
              "is-invalid"
            );
          })

        /* Init value state */
        this.#_.states.value = new Ref({
          name: "value",
          owner: this,
        }).effects
          .add(
            /* Validate and set message state */
            (current) => {
              this.setCustomValidity("");
              const pipe = [];

              /* required */
              if (this.required) {
                pipe.push((value) => {
                  if (value === null) {
                    return "Required";
                  }
                });
              }

              /* email and url */
              if (["email", "url"].includes(this.type)) {
                pipe.push(() => {
                  if (this.validity.typeMismatch) {
                    return "Invalid format";
                  }
                });
              }

              /* pattern */
              if (this.pattern) {
                pipe.push(() => {
                  if (this.validity.patternMismatch) {
                    return "Invalid format";
                  }
                });
              }

              /* min */
              if (this.min !== undefined) {
                if (this.type === "numeric") {
                  pipe.push((value) => {
                    if (value < this.min) {
                      this.setCustomValidity(" ");
                      return "Too low";
                    }
                  });
                } else {
                  pipe.push((value) => {
                    if (value.length < this.min) {
                      this.setCustomValidity(" ");
                      return "Too short";
                    }
                  });
                }
              }

              /* max */
              if (this.max !== undefined) {
                if (this.type === "numeric") {
                  pipe.push((value) => {
                    if (value > this.max) {
                      this.setCustomValidity(" ");
                      return "Too high";
                    }
                  });
                } else {
                  pipe.push((value) => {
                    if (value.length > this.max) {
                      this.setCustomValidity(" ");
                      return "Too long";
                    }
                  });
                }
              }

              /* custom */
              if (this.validators) {
                this.validators.forEach((validator) => {
                  pipe.push((value) => {
                    const message = validator(value);
                    if (message) {
                      this.setCustomValidity(" ");
                      return message;
                    }
                  });
                });
              }

              for (const validator of pipe) {
                const message = validator(current);
                if (message) {
                  this.#_.states.message.$ = message;
                  break;
                }
              }

              this.checkValidity();
            }
          )
          

        this.id = create_id();
        /* Prevent browser default validation message */
        this.title = " ";
        this.classes.add("form-control");
        /* Set visisted attribute on blur */
        this.on.blur = (event) => (this.attribute.visited = true);
      }

      __new__() {
        super.__new__?.();
      }

      /* Returns message effects controller. 
      NOTE Allows external addition of message 
      effects without exposing data and already-added 
      effects. */
      get message() {
        return this.#_.states.message.effects;
      }

      /* Returns max constraint. */
      get max() {
        return this.#_.max;
      }

      /* Sets max constraint. */
      set max(max) {
        this.#_.max = max;
      }

      /* Returns min constraint. */
      get min() {
        return this.#_.min;
      }

      /* Sets min constraint. */
      set min(min) {
        this.#_.min = min;
      }

      /* Returns type. */
      get type() {
        return this.#_.type || "text";
      }

      /* Sets type. */
      set type(type) {
        if (!this.#_.types.includes(type)) {
          throw new Error(`Unsupported type: ${type}`);
        }
        this.#_.type = type;
        if (type === "numeric") {
          type = "text";
        }
        super.type = type;
      }

      /* Returns valid state. */
      get valid() {
        return this.state.$.valid;
      }

      /* Returns custom validators. */
      get validators() {
        return this.#_.validators;
      }

      /* Sets custom validators. */
      set validators(validators) {
        if (validators) {
          validators = Object.freeze([...validators]);
        }
        this.#_.validators = validators;
      }

      __init__() {
        super.__init__?.();

        /* Self-correct numeric input */
        this.on.input = (event) => {
          if (this.type === "numeric") {
            if (!is_numeric(super.value)) {
              super.value = super.value.slice(0, -1);
            }
          }
        };

        /* Set value state from input value */
        this.on.input$run = (event) => {
          if (this.type === "numeric") {
            this.#_.states.value.$ = this.#_.numchars.includes(super.value)
              ? null
              : Number(super.value.replace(",", "."));
          } else {
            const value = super.value.trim();
            this.#_.states.value.$ = value === "" ? null : value;
          }
        };
      }
    };
  };
</script>
